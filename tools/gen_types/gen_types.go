package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"text/template"
)

// The 'go:generate' comment appears in internal/type_system/type_system.go.
// These paths are relative to that file.
const inputPath = "./types.go"
const outputPath = "./types_gen.go"

func main() {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputPath, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Error parsing file: %v", err)
	}

	var typeStructs []string

	// Find all struct types that implement Type interface
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// Check if this type has a provenance field
		hasProvenance := false
		for _, field := range structType.Fields.List {
			if len(field.Names) > 0 && field.Names[0].Name == "provenance" {
				hasProvenance = true
				break
			}
		}

		if hasProvenance {
			// Verify this is a Type by checking for isType method
			for _, decl := range node.Decls {
				funcDecl, ok := decl.(*ast.FuncDecl)
				if !ok {
					continue
				}

				if funcDecl.Recv != nil && len(funcDecl.Recv.List) > 0 {
					starExpr, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr)
					if !ok {
						continue
					}

					ident, ok := starExpr.X.(*ast.Ident)
					if !ok {
						continue
					}

					if ident.Name == typeSpec.Name.Name && funcDecl.Name.Name == "isType" {
						typeStructs = append(typeStructs, typeSpec.Name.Name)
						break
					}
				}
			}
		}

		return true
	})

	// Generate WithProvenance methods
	var buf bytes.Buffer
	buf.WriteString("// Code generated by tools/gen_types.go; DO NOT EDIT.\n\n")
	buf.WriteString("package type_system\n\n")
	buf.WriteString("import . \"github.com/escalier-lang/escalier/internal/provenance\"\n\n")

	tmpl := template.Must(template.New("withProvenance").Parse(`
func (t *{{.}}) Provenance() Provenance     { return t.provenance }
func (t *{{.}}) SetProvenance(p Provenance) { t.provenance = p }
func (t *{{.}}) Copy() Type {
    result := *t // Create a copy of the struct
    return &result
}
`))

	for _, typeName := range typeStructs {
		err = tmpl.Execute(&buf, typeName)
		if err != nil {
			log.Fatalf("Error executing template: %v", err)
		}
	}

	// Format the generated code
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Error formatting code: %v", err)
	}

	// Write to file
	err = os.WriteFile(outputPath, formattedCode, 0644)
	if err != nil {
		log.Fatalf("Error writing file: %v", err)
	}

	fmt.Printf("Generated WithProvenance methods for %d types\n", len(typeStructs))
}
