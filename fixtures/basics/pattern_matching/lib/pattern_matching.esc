// Basic pattern matching examples

type Point = {x: number, y: number}

// Simple literal matching
val num1: number = 5
export val literalMatch = match num1 {
    1 => "one",
    2 => "two", 
    5 => "five",
    _ => "other"
}

// Variable binding pattern
var num2: number = 42
export val variableMatch = match num2 {
    x => x * 2
}

// Tuple pattern matching
export val tupleValue: [number, number, number] = [1, 2, 3]
export val tupleMatch = match tupleValue {
    [a, b, c] => a + b + c,
    _ => 0
}

// Object pattern matching
export val objectValue: Point = {x: 10, y: 20}
export val objectMatch = match objectValue {
    {x, y} => x + y,
    _ => 0
}

// Object pattern with renaming
export val objectRename = match objectValue {
    {x: a, y: b} => a * b,
    _ => 0
}

// Nested pattern matching
export val nestedValue: {point: [number, number]} = {point: [1, 2]}
export val nestedMatch = match nestedValue {
    {point: [x, y]} => x + y,
    _ => 0
}

// Pattern matching with guards
val tuple2: [number, number] = [3, 3]
export val guardMatch = match tuple2 {
    [a, b] if a == b => "equal",
    [a, b] => "not equal"
}

// Multiple cases
val str: string = "hello"
export val multiCase = match str {
    "hi" => "greeting",
    "hello" => "salutation", 
    "bye" => "farewell",
    _ => "unknown"
}

// Boolean literal matching
val bool: boolean = true
export val boolMatch = match bool {
    true => "yes",
    false => "no"
}

// Mixed literal and variable patterns
val num3: number = 7
export val mixedMatch = match num3 {
    1 => "one",
    2 => "two",
    n => "number: " ++ n.toString()
}

// Tuple rest patterns
export val longTuple: [number, number, number] = [1, 2, 3]
export val tupleRestMatch = match longTuple {
    [first, ...rest] => rest,
    _ => 0
}

// Object rest patterns
type ExtendedPoint = {x: number, y: number, z: number, name: string}
export val extendedPoint: ExtendedPoint = {x: 1, y: 2, z: 3, name: "point"}
export val objectRestMatch = match extendedPoint {
    {x, y, ...rest} => rest,
    _ => 0
}

declare val ref: {value: string | number | boolean}
export val refMatch = match ref {
    {value: a:string} => "string",
    {value: b:number} => "number",
    {value: c:boolean} => "boolean",
}

class Color(r: number, g: number, b: number) {
	r,
	g,
    b,
    static [Symbol.customMatcher](subject: Color) -> [number, number, number] {
        return [subject.r, subject.g, subject.b]
    },
}
class Event(kind: string) {
	kind,
    static [Symbol.customMatcher](subject: Event) -> [string] {
        return [subject.kind]
    },
}
declare val obj: Color | Event

// Class instance patterns
val result1 = match obj {
	Color {r, g, b} => r + g + b,
	Event {kind} => kind,
}

// Extractor patterns
val result2 = match obj {
	Color(r, g, b) => r + g + b,
	Event(kind) => kind,
}
